\documentclass[a4paper,10pt]{article}
\usepackage[a4paper,margin=2cm]{geometry}
\usepackage{multicol}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{titlesec}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{booktabs}

% Farben für Code
\definecolor{codebg}{RGB}{245,245,245}
\definecolor{keyword}{RGB}{0,0,180}
\definecolor{comment}{RGB}{0,128,0}
\definecolor{string}{RGB}{163,21,21}

\lstset{
  backgroundcolor=\color{codebg},
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{keyword}\bfseries,
  commentstyle=\color{comment},
  stringstyle=\color{string},
  numbers=left,
  numberstyle=\tiny,
  breaklines=true,
  frame=single,
  showstringspaces=false,
  tabsize=4
}

% Layout für die Überschriften
\titleformat{\section}{\large\bfseries}{}{0em}{}
\titleformat{\subsection}{\normalsize\bfseries}{}{0em}{}

% Kopf- und Fußzeile
\pagestyle{fancy}
\fancyhf{}
\lhead{Bash Cheat Sheet}
\rhead{\thepage}

\begin{document}

\begin{center}
	{\LARGE \textbf{Bash Cheat Sheet}} \\[1em]
	{\large A quick guide to the Bash programming language}
\end{center}

\tableofcontents

\vspace{0.5cm}

% Section 1: Basics
\section{Basics}
\subsection{Hello, World}
\begin{lstlisting}[language=bash]
#!/bin/bash             # Linux
#!/usr/local/bin/bash   # BSD
#!/usr/bin/env bash     # Portable across systems
echo "Hello World!"
\end{lstlisting}

\subsection{.bashrc}
Normaly, in the home directory is the bashrc file.
This file can be used to save alias an selfmade functions.
To reload the bashrc \verb| . ~/.bashrc |
\subsubsection*{Example}
\begin{lstlisting}[language=bash]
# ~/.bashrc
#

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

alias ls='ls --color=auto'
alias grep='grep --color=auto'
PS1='[\u@\h \W]\$ '
export GREP_COLORS='mt=1;35'
export LS_COLORS="di=1;35:fi=0:ln=36"

alias grep='grep --color=auto'
alias ls='ls --color=auto'
alias sl='ls -lh --color=auto'

fuzzy() {
  local file
  file=$(find . -type f | fzf --preview 'cat {}' --height 80% --border)
  [[ -n "$file" ]] && nvim "$file"
}

trs() {
  local file
  local filename
  file="$1"
  filename=$(basename "$file")
  mv "$file" /tmp/"$filename"
}
\end{lstlisting}

\subsection{Basic Commands}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|pwd| \> Shows the current working directory \\
	\> \verb|ls -l| \> Lists all directory contents\\
	\> \verb|ls -a| \> show hidden files \verb|.files|\\
	\> \verb|ls -h| \> show size human readable\\
	\> \verb|cd /path/| \> Changes to the specified directory \\
	\> \verb|clear| \> Clears the terminal screen \\
	\> \verb|man ls| \> Shows documentation for the \verb|ls| command \\
	\> \verb|!!| \> Executes the last command \\
	\> \verb|history| \> Shows a list of previous commands \\
	\> \verb|which cmd| \> shows if the path to the command \\
	\> \verb|type cmd| \> shows if the command is aliased \\
	\> \verb|man cmd| \> shows the documentation of the cmd, external\\
	\> \verb|help cmd| \> shows the documentation of the cmd, builtin \\
	\> \verb|cmd --help| \> shows the documentation of the cmd, sometimes \\
	\> \verb|compgen -b| \> shows all builtin cmd \\
	\> \verb|file date| \> what kind of file date is \\
\end{tabbing}

\subsection{Word Count WC}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|wc data.txt| \> counts lines, words, bytes \\
	\> \verb| -l | \> counts lines \\
	\> \verb| -w | \> counts words \\
	\> \verb| -c | \> counts Bytes \\
	\> \verb| -m | \> counts characters \\
	\> \verb| -L | \> lenth of the longest line \\
\end{tabbing}

\subsection{Input and Output Terminal}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{100mm} \kill
	\> \verb|echo "Hallo, $name"| \> Prints Hallo and the value of \verb|name| \\
	\> \verb|read name| \> Reads terminal input into \verb|name| \\
	\> \verb|read -p "Name please: " name| \> Reads terminal input with a prompt \\
	\> \verb|read -s| \> Hidden input, useful for passwords \\
	\> \verb|read -r| \> Prevents interpretation of backslashes \\
\end{tabbing}

\subsection{alias}
\begin{lstlisting}[language=bash]
#!/bin/bash
# Like functions, but simpler; no parameters, often used to combine commands
alias myfunc='ls -la'
\end{lstlisting}

\subsection{Data and Directory Manipulation}
\begin{tabbing}
	\= \hspace{70mm} \= \hspace{100mm} \kill
	\> \verb|cp -r /from/path/ /to/path/| \> Copies a directory with its contents \\
	\> \verb|cp /from/path/* /to/path/| \> Copies the contents of a directory \\
	\> \verb|mv /from/path/ /to/path/| \> Moves or renames a directory \\
	\> \verb|mv /from/path/* /to/path/| \> Moves the contents of a directory \\
	\> \verb|rm -rf thing| \> Deletes a file or directory (force) \\
	\> \verb|rm -i| \> asking if the file shout be removed\\
	\> \verb|mkdir bunga| \> Creates the directory \verb|bunga| \\
	\> \verb|touch data.txt| \> Creates an empty file \verb|data.txt| \\
	\> \verb|echo "bunga" > data.txt| \> Writes bunga to the file (overwrites) \\
	\> \verb|echo "bunga" >> data.txt| \> Appends bunga to the file \\
	\> \verb|sed 's/heinz/horst/g' data.txt| \> Replaces all heinz with horst in the file \\
	\> \verb|sed 's/heinz/horst/3' data.txt| \> Replaces the third occurrence of heinz with horst \\
	\> \verb|awk '{print $1}' data.txt| \> Prints the first column of the file \\
	\> \verb|awk '/bunga/ {print}' data.txt| \> Prints lines containing bunga \\
	\> \verb|cut -d "," -f 1 data.csv| \> Extracts the first column from CSV \\
	\> \verb|cut -d ":" -f 1,3 file.txt| \> Extracts columns 1 and 3 (delimiter \:) \\
	\> \verb|cut -c 1-5 file.txt| \> Extracts characters 1 to 5 from each line \\
	\> \verb|cut -d "," -f 2 --complement file.csv| \> Extracts all columns except the second \\
\end{tabbing}

\subsection{Permission}
\begin{tabbing}
	\= \hspace{70mm} \= \hspace{100mm} \kill
	\> \verb| ls -l | \> shows the permissions \\
	\> \verb| chmod +x script.sh | \> makes script executable \\
	\> \verb| chmod mod data | \> changes the permissions \\
	\> \verb| chown user:group data| \> changes user and group \\
	\> \verb| chgrp group data | \> changes group \\
	\> \verb| umask mod | \> sets the default for new date \\
	\> \verb|     mod | \> {\small owner-group-others} \\
	\> \verb|     777 | \> \verb|rwx-rwx-rwx| all rights for everyone \\
	\> \verb|     755 | \> \verb|rwx-r-x-r-x| owner all, rest read and execute \\
	\> \verb|     700 | \> \verb|rwx--------| only owner\\
	\> \verb|     644 | \> \verb|rw--r---r--| owner read and write, rest only read \\
	\> \verb|     600 | \> \verb|rw---------| owner read and write \\
	\> \verb|     400 | \> \verb|r----------| owner read \\
	\> \verb|     000 | \> \verb|-----------| now rights \\
\end{tabbing}

\subsection{Viewer and Pager}
\begin{tabbing}
	\= \hspace{70mm} \= \hspace{100mm} \kill
	\> \verb|cat data.txt| \> Shows the content of \verb|data.txt| \\
	\> \verb|cat -n date.txt| \> Shows data with linenumber\\
	\> \verb|cat -s date.txt| \> compines empty lines together\\
	\> \verb|cat -E date.txt| \> shows \verb|$| at the end of the line\\
	\> \verb|cat -T date.txt| \> shows \verb|^I| as tabs \\
	\> \verb|less data.txt| \> Pager, views content, better for long files \\
	\> \verb|less -N date.txt| \> shows linenumber \\
	\> \verb|less -S date.txt| \> cuts of longe lines \\
	\> \verb|less keycombis | \> \\
	\> \verb|    b | \> moves a page back \\
	\> \verb|    f | \> moves a page forword \\
	\> \verb|    j | \> moves a line down \\
	\> \verb|    k | \> moves a line up \\
	\> \verb|    g | \> jumps to the beginning \\
	\> \verb|    G | \> jumps to the end \\
	\> \verb|    /word | \> searches for word \\
	\> \verb|    n | \> jumps the the next finding \\
	\> \verb|    N | \> jumps to the finding before \\
	\> \verb|    q | \> quits the pager \\
\end{tabbing}

\subsection{Pipe and Redirection}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|command1 | command2| \> Pipes output of \verb|command1| into \verb|command2| \\
	\> \verb|> | \> Overwrites the file with the new output \\
	\> \verb|>> | \> Appends output to the end of the file \\
	\> \verb|< | \> Reads data as input \\
	\> \verb|< < ( ... ) | \> Output like it is from a data file \\
	\> \verb|> > ( ... ) | \> Input like it is from a data file \\
\end{tabbing}

\section{Multithreading}
\subsection{Jobs}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|jobs| \> Lists jobs running in the background \\
	\> \verb|bg \%1| \> Continues a paused job in the background (e.g., job 1) \\
	\> \verb|fg \%1| \> Brings a background job to the foreground (e.g., job 1) \\
	\> \verb|kill -STOP $PID| \> Stops a job (replace PID with process ID) \\
	\> \verb|kill -CONT $PID| \> Continues a stopped job \\
\end{tabbing}

\subsection{backround process}
\begin{lstlisting}[language=bash]
  #!/bin/Bash 

  # Process starting 
  long_running_command & 

  # getting background PID 
  pid=$! 

  # waiting until background is done 
  wait "$pid" 
  
  # killing background process 
  kill "$pid"

  # starting a seperated process 
  sep_command & 
  disown 

  \end{lstlisting}

\section{Basic Commands}
\subsection{find}
\subsubsection*{Example}
\begin{lstlisting}[language=bash]
#!/bin/bash

# Finding data.txt in /path
find /path -type f -name "data.txt"
\end{lstlisting}

\subsubsection*{Parameters}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|-type f| \> Searches for files \\
	\> \verb|-type d| \> Searches for directories \\
	\> \verb|-name "bunga"| \> Searches for bunga \\
	\> \verb|-iname "bUnga"| \> Ignores case (e.g., bUnga, BUNGA) \\
	\> \verb|-mtime -n| \> Finds files modified in the last n days \\
	\> \verb|-size +n| \> Finds files larger than n (e.g., +10M for 10MB) \\
	\> \verb|-exec command {} \;| \> Executes a command on found files \\
	\> \verb|-print0 | \> seperator is the Nullbyte \\
\end{tabbing}

\subsection{grep}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|grep "pattern" *.txt| \> Searches for pattern in \.txt files \\
	\> \verb|grep -i "pattern" *.txt| \> Ignores case Aa \\
	\> \verb|grep -r "pattern" /path| \> Searches recursively in /path \\
	\> \verb|grep -n "pattern" *.txt| \> Shows line numbers of matches \\
	\> \verb|grep -l "pattern" *.txt| \> Lists files containing pattern \\
	\> \verb|grep -v "pattern" *.txt| \> Shows lines not matching pattern \\
	\> \verb|grep -o '^bunga.' /path| \> Shows starting wit bunga, does not care about the other\\
	\> \verb|grep '^bunga' /path| \> looks for bunga at the beginning\\
	\> \verb|grep 'bunga$' /path| \> looks for bunga at the end\\
	\> \verb|grep -A2 bunga /path| \> shows 2 lines after bunga\\
	\> \verb|grep -B2 bunga /path| \> shows 2 lines before bunga\\
	\> \verb|grep -C2 bunga /path| \> shows 2 lines arround bunga\\
\end{tabbing}

\subsection{awk}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|awk '{print $1}' data.txt| \> Prints the first column \\
	\> \verb|awk '/pattern/ {print}' data.txt| \> Prints lines with pattern \\
	\> \verb|awk -F "," '{print $1}' data.csv| \> Prints the first column of a CSV \\
	\> \verb|awk '{print NR, $NF}' file.txt| \> Prints line number and last column \\
	\> \verb|$0 | show the hole line \\
	\> \verb|$1, $2, ... , $n| \> single fields \\
	\> \verb|NR | \> Counter of the worked on lines \\
	\> \verb|NF | \> Counter of the single fields, can be used to show the last field \\
	\> \verb|FNR | \> Linenumbers of the current file \\
	\> \verb|FS | \> field separator, normaly whitespace \\
	\> \verb|OFS | \> output field separator, normaly whitespace \\
	\> \verb|RS | \> record separator, normaly \\
	\> \verb|ORS | \> output record separator, normaly \\
\end{tabbing}

\subsection{sort}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|sort file.txt| \> Sorts lines of \verb|file.txt| alphabetically \\
	\> \verb|sort -r file.txt| \> Sorts in reverse order \\
	\> \verb|sort -n file.txt| \> Sorts numerically \\
	\> \verb|sort -k 2 file.txt| \> Sorts by the second column \\
	\> \verb|sort -t "," -k 1 data.csv| \> Sorts CSV by the first column \\
	\> \verb|sort -u file.txt| \> Sorts and removes duplicate lines \\
\end{tabbing}

\subsection{tar}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|tar -cvf archive.tar dir/| \> Creates an archive \\
	\> \verb|tar -zcvf archive.tar.gz dir/| \> Creates a gzip archive \\
	\> \verb|tar -xvf archive.tar| \> Extracts an archive \\
	\> \verb|tar -tvf archive.tar| \> Shows the archive contents \\
\end{tabbing}

\subsection{translate}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb!echo "a:b:c" | tr : '\n'! \> changes colon into a  new line \\
	\> \verb!echo "hello" | tr -d 'l' [heo]! \> deletes l \\
	\> \verb!echo "abbbc" | tr -s 'b' [abc]! \> compines the same caracters \\
	\> \verb!echo "bunga1234" | tr -cd '[:digit:]' [1234] ! \> deletes the letters \\
\end{tabbing}

\subsection{Parameter Expansion}
\begin{lstlisting}[language=bash]
${var%s}     # removes suffix, 180s to 180
${file%%.*}  # removes longer suffix, backup.tar.gz to backup
${path#*/}   # removes prefix, /home/bunga/ to home/bunga/
${path##*/}  # removes longer prefix, /home/bunga/bunga.pdf to bunga.pdf
\end{lstlisting}

\subsection{Examle}
\begin{lstlisting}[language=bash]
#!/bin/bash 

# grep
grep '^Error' logfile               # lines beginning with "Error"
grep -E 'foo|bar' datei.txt         # lines containing "foo" or "bar"
grep -E '\d{4}-\d{2}-\d{2}' log.txt # match date pattern YYYY-MM-DD (e.g. 2025-11-01)

# sed
sed 's/foo/bar/g' datei.txt         # replace all "foo" with "bar" in every line
sed -E 's/[0-9]+/NUM/g' datei.txt   # replace all sequences of digits with "NUM"

# awk
awk '/^Error/ {print $0}' logfile   # print lines that start with "Error"
awk '/foo|bar/ {counter++} END {print counter}'  # count lines containing "foo" or "bar"

# find
find . -regex '.*\.txt'             # find all .txt files (regex on full path)
find . -regex '.*/[A-Z].*'          # find files whose name starts with a capital letter
\end{lstlisting}

\section{Variables and Arrays}
\subsection{declare}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|-a | \> declares an Array \\
	\> \verb|-A | \> declares an Key/Value Array \\
	\> \verb|-i | \> declares as int \\
	\> \verb|-r | \> declares an readonly variable \\
	\> \verb|-x | \> export the variable \\
	\> \verb|-p | \> shows the attributes of an variable \\
	\> \verb|-f | \> shows the code of a function \\
	\> \verb|-u | \> converts Value in lower case letters \\
	\> \verb|-l | \> converts Value in upper case letters \\
	\> \verb|-n | \> references the name \\
\end{tabbing}

\subsection{Variables}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|bunga="1"| \> Creates variable \verb|bunga| with value 1 \\
	\> \verb|bunga=("1" "2")| \> Creates an array \verb|bunga| \\
	\> \verb|echo $bunga| \> Prints the variable (or first array element) \\
	\> \verb|export bunga| \> Makes \verb|bunga| available to subprocesses \\
\end{tabbing}

\subsection{Spezial Variables}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb| $0 | \> name of the current running script \\
	\> \verb| $1, $2 ..... | \> arguments \\
	\> \verb| $# | \> number of arguments \\
	\> \verb| $@ | \> all arguments in ' '\\
	\> \verb| $* | \> all arguments as strings \\
	\> \verb| $$ | \> PID from current process \\
	\> \verb| $! | \> PID from last backround process \\
	\> \verb| $? | \> exit-code from the last command \\
	\> \verb| $_ | \> last arguments from the last 1920x-240command \\
	\> \verb| $- | \> current shell option \\
	\> \verb| $PWD | \> current working directory \\
	\> \verb| $UID | \> User-ID \\
	\> \verb| $EUID | \> effectiv User-ID \\
	\> \verb| $PATH | \> list where bash looks for programs and cmd \\
	\> \verb| env | \> lists all environment variables \\
\end{tabbing}

\subsection{Array read in}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|mapfile | \> reads from Source into the Array \\
	\> \verb| -d | \> seperator \\
	\> \verb| -d '' | \> Nullbyte as seperator (for -print0)\\
	\> \verb| -t | \> removes the seperator \\
	\> \verb| -n COUNT | \> reads from COUNT line \\
	\> \verb| -s COUNT | \> jumps over COUNT line \\
	\> \verb| -O COUNT | \> beginns at COUNT line \\
\end{tabbing}

\subsubsection*{Arrays and Loops}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|${array[@]}| \> All items in the array \\
	\> \verb|${!array[@]}| \> Iterates through indices \\
	\> \verb|${#array[@]}| \> Length of the array \\
	\> \verb|${array[$i]}| \> Shows item at index \verb|$i| \\
	\> \verb|myarray+=("x")| \> adds one item \\
\end{tabbing}

\section{String manipulation}
\subsection{Adding}
\begin{lstlisting}[language=bash]
#!/bin/bash 
val1="heinz"
val2="horst"

new="${heinz}_${horst}"
echo "$new"

Output: heinz_horst
\end{lstlisting}

\subsection{Basename}
\begin{lstlisting}[language=bash]
#!/bin/bash 

path="$HOME/Downloads/image.png"

# extracting the filename 
filename="${path##*/}" 

# extracting the name without sufix 
path=$(dirname "$filename")
file=${basename "%.*"} 

# or 
file=$(basename "$filename" .txt)
path=$(dirname "$filename")
\end{lstlisting}

\section{Operators}
\subsection{Arithmetic Operators}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|(( ))| \> math has to be in double brakets \\
	\> \verb|+| \> Addition \\
	\> \verb|-| \> Subtraction \\
	\> \verb|*| \> Multiplication \\
	\> \verb|/| \> Division \\
	\> \verb|\%| \> Modulus (remainder of division) \\
\end{tabbing}

\subsection{String Comparison Operators}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|==| \> Equal to \\
	\> \verb|!=| \> Not equal to \\
	\> \verb|<| \> Less than (ASCII order) \\
	\> \verb|>| \> Greater than (ASCII order) \\
	\> \verb|=~| \> Regex \\
	\> \verb|=~ ^...| \> checks from the beginning \\
	\> \verb|=~ ...$| \> checks from the end \\
	\> \verb|=~ [abc] | \> includes letters \\
	\> \verb|=~ [0-9]| \> includes numbers \\
	\> \verb|=~ [...]{n}| \> includes n characters \\
\end{tabbing}

\subsection{Comparison Operators}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|-eq| \> Equal to \\
	\> \verb|-ne| \> Not equal to \\
	\> \verb|-lt| \> Less than \\
	\> \verb|-le| \> Less than or equal to \\
	\> \verb|-gt| \> Greater than \\
	\> \verb|-ge| \> Greater than or equal to \\
\end{tabbing}

\subsection{Logical Operators}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|&&| \> Logical AND \\
	\> \verb!||! \> Logical OR \\
	\> \verb|!| \> Logical NOT \\
\end{tabbing}

\subsection{File Operators}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|-f| \> checks if file exists \\
	\> \verb|-e| \> Checks if file or directory exists \\
	\> \verb|-d| \> Checks if directory exists \\
	\> \verb|-s| \> Checks if file is not empty \\
	\> \verb|-r| \> checks if file is readable \\
	\> \verb|-w| \> checks if file is writable \\
	\> \verb|-x| \> checks if file is executable \\
	\> \verb|-z| \> checks if empty (zero length) \\
	\> \verb|-n| \> checks if not empty (non-zero length) \\
	\> \verb|-h| \> checks if symbolic link \\
\end{tabbing}

\section{Testing}
\subsection{Testing basics}

\begin{lstlisting}[language=bash]
#!/bin/bash 
if [[ ... ]]; then 
  echo "true"
fi 

[[ ... ]]                   # 0 if true, 1 if false 
[[ ... ]] || command        # if testing is false then command 
[[ ... ]] && command        # if testing is true then command 

[[ ... ]] || continue       # only in a Loop (if, while, until) 
                            # stopps the current loop run, 
                            # moves on with the next iteration
[[ ... ]] || return         # only in a Function 
                            # stopps the function
[[ ... ]] || exit           # ends the script
\end{lstlisting}

\subsection{Testing with numbers}
\begin{lstlisting}[language=bash]
#!/bin/bash 
# numbers
[[ 5 -eq 5 ]]               # 5 = 5 
[[ 7 -ne 3 ]]               # not equal 
[[ 5 -gt 3 ]]               # 5 > 3 
[[ 2 -lt 4 ]]               # 2 < 4 
[[ 3 -ge 3 ]]               # 3 >= 3 
[[ 4 -le 6 ]]               # 4 <= 6
[[ $a -gt 3 && $b -lt 10 ]]
[[ $a -eq 1 || $b -eq 2 ]]
\end{lstlisting}

\subsection{Testing with strings}
\begin{lstlisting}[language=bash]
#!/bin/bash 
# strings 
[[ $a = "foo" ]]            # equal 
[[ $a != "foo" ]]           # not equal 
[[ -z $a ]]                 # is empty (zero length)
[[ -n $a ]]                 # is not empty (non-zero length)
[[ $a == f* ]]               # pattern matches, beginning with f 
[[ $a =~ ^[0-9]+$ ]]        # contains only numbers 
[[ $a =~ ^bunga ]]          # begins with bunga 
[[ $a =~ bunga$ ]]          # ends with bunga 
[[ $a =~ \.pdf$ ]]          # is a pdf file 
[[ $a =~ ^[a-z]{3}[0-9]{5}$ ]]  # three letters and five numbers
\end{lstlisting}

\subsection{Testing with data}
\begin{lstlisting}[language=bash]
#!/bin/bash 
# data 
[[ -f data.txt ]]           # is file existing?
[[ -d data ]]               # is directory existing? 
[[ -e path/data ]]          # is is file or directory existing?
[[ -r data.txt ]]           # is data.txt readable? 
[[ -w data.txt ]]           # is data.txt writable? 
[[ -x script.sh ]]          # is script.sh executable?
\end{lstlisting}

\section{Regex}
\subsection{Linux Tools}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|grep| \> basic regex \\
	\> \verb|grep -E| \> extended regex \\
	\> \verb|grep -P| \> perl regex (PCRE) \\
	\> \verb|sed| \> basic regex (substitution with s///) \\
	\> \verb|awk| \> extended regex \\
	\> \verb|find| \> emacs-style regex (leicht anders) \\
\end{tabbing}

\subsection{Parameters}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb| . | \> random character, e.g.\ a.c → abc, axc, a8c \\
	\> \verb| ^ | \> beginning of the line \\
	\> \verb| $ | \> end of the line \\
	\> \verb| [ ] | \> character class, e.g.\ [abc] = a or b or c \\
	\> \verb| [^ ] | \> negation, e.g. $\ [^0-9]$ = not a digit \\
	\> \verb| * | \> zero or more repetitions, fo* → f, fo, foo \\
	\> \verb| + | \> one or more repetitions, only with -E or -P \\
	\> \verb| ? | \> zero or one repetition, only with -E or -P \\
	\> \verb| {n,m} | \> repetitions, e.g.\verb|\ [0-9]{2,4}| = 2 to 4 digits \\
	\> \verb| () | \> grouping (used for subpatterns) \\
	\> \verb| | | \> OR, e.g.\ foo|bar \\
	\> \verb| \b | \> word boundary, e.g.\ \verb|\bfoo\b| matches “foo” as a whole word \\
	\> \verb| \s | \> whitespace character (space, tab, etc.) \\
	\> \verb| \d | \> digit (0–9) \\
	\> \verb| \w | \> word character (letters, digits, underscore) \\
	\> \verb| s/.../.../ | \> substitute (search and replace) \\
	\> \verb| g | \> global flag, replace all matches in a line \\
\end{tabbing}

\subsection{Regex in Bash Scripts}
\subsubsection{One usage of Regex}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|[[ string =~ regex ]]| \> testet, ob \verb|string| dem Muster entspricht \\
	\> \verb|=~| \> Bash Regex-Matching Operator \\
	\> \verb|^ $| \> Anfang / Ende des Strings \\
	\> \verb|( )| \> Gruppierung, Zugriff über \verb|BASH_REMATCH| \\
	\> \verb|[ ]| \> Zeichenklasse \\
	\> \verb|[^ ]| \> Negation \\
	\> \verb|* + ? {n,m}| \> Wiederholungen (wie gewohnt, ERE) \\
	\> \verb|\| \> Escape-Zeichen (vorsichtig in Quotes!) \\
\end{tabbing}

\subsubsection{Example}
\begin{lstlisting}[language=bash]
#!/bin/bash

# Einfaches Matching
text="hello123"
if [[ $text =~ ^hello[0-9]+$ ]]; then
  echo "Match!"
else
  echo "No match!"
fi
# -> prueft, ob text mit "hello" beginnt und mit einer Zahl endet


# Zugriff auf Gruppen mit BASH_REMATCH
input="Name: Alice, Age: 25"
if [[ $input =~ Name:\ ([A-Za-z]+),\ Age:\ ([0-9]+) ]]; then
  echo "Name: ${BASH_REMATCH[1]}"
  echo "Age: ${BASH_REMATCH[2]}"
fi
# -> BASH_REMATCH[0] = gesamter Treffer
# -> BASH_REMATCH[1], [2], ... = Gruppen


# Variable in Regex einbauen
pattern="foo"
if [[ "foobar" =~ ^${pattern}bar$ ]]; then
  echo "Pattern variable works!"
fi


# Negation
if ! [[ "123" =~ ^[A-Za-z]+$ ]]; then
  echo "Contains non-letters"
fi


# Pruefen, ob eine Eingabe nur aus Zahlen besteht
read -p "Enter number: " num
if [[ $num =~ ^[0-9]+$ ]]; then
  echo "Valid number"
else
  echo "Not a number"
fi
\end{lstlisting}

\subsubsection{Important Note}

\begin{itemize}
	\item Keine Anführungszeichen um den Regex!
	      → \verb|[[ $var =~ regex ]]|
	      → \verb|[[ $var =~ "regex" ]]|  (würde als Stringliteral behandelt)
	\item Bash nutzt **Extended Regular Expressions (ERE)**, wie \verb|grep -E|.
	\item Escape-Zeichen (\verb|\|) sind tricky, da Bash sie **vor** der Regex-Engine interpretiert.
	      → oft muss man doppelt escapen, z.\,B. \verb|\\.| für einen Punkt.
	\item Ergebnis des Regex-Vergleichs:
	      \verb|$?| ist 0 (true) bei Match, 1 (false) bei keinem Match.
	\item Gruppenergebnisse stehen in \verb|${BASH_REMATCH[@]}|.
\end{itemize}

\section{Options}
\subsection{Variables with Parameters}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|path=${1:-bunga}| \\
	\> \verb|$1| \> first Paramter is used \\
	\> \verb|$2| \> second Paramter is used \\
	\> \verb|:-| \> use bunga if Paramter is empty \\
\end{tabbing}

\subsection{getopts}
\begin{lstlisting}[language=bash]
#!/bin/bash 

# Command for Arguments 

# Errorhandling 
# 0 for handling with : and \?
# 1 getopts writes his one errors
OPTERR=0

# Index of Arguments 
# OPTIND starts with 1 
# OPTIND=2 -> bunga
# OPTIND=5 -> heinz

# ./script.sh -a bunga -b -c heinz 
while getopts "a:bc:" opt; do 
  case $opt in 
    a) 
      echo "Option -a with argument"
      a_arg="$OPTARG" 
    ;; 
    b) echo "Option -b without argument" ;;
    c) 
      echo "Option -c with argument"
      c_arg="$OPTARG"
    ;;
    \?) echo "Unvalid argument" ;; 
    :) echo "Option needs an argument" ;;
  esac 
done 
\end{lstlisting}

\section{Loops}
\subsection{for}
\begin{lstlisting}[language=bash]
#!/bin/bash
for i in {1..5}; do
  echo $i
done

# Arrays with items
for item in "${array[@]}"; do 
  echo "$item"
done 

# Arrays with indices
for i in "${!array[@]}"; do 
  echo "Index $i: ${array[$i]}"
done
\end{lstlisting}

\subsection{while}
\begin{lstlisting}[language=bash]
#!/bin/bash
count=2

while [ $count -le 5 ]; do
  echo $count
  ((count++))
done

# Arrays
i=0 
while [ $i -lt ${#array[@]} ]; do 
  echo "${array[$i]}"
  ((i++))  % Fixed: Corrected {{i++}} to ((i++))
done
\end{lstlisting}

\subsection{until}
\begin{lstlisting}[language=bash]
#!/bin/bash
count=1
until [ $count -gt 5 ]; do
  echo $count
  ((count++))
done

# Arrays 
i=0 
until [ $i -ge ${#array[@]} ]; do 
  echo "${array[$i]}"
  ((i++))  % Fixed: Corrected {{i++}} to ((i++))
done
\end{lstlisting}

\subsection{break and continue}
\begin{lstlisting}[language=bash]
#!/bin/bash
for i in {1..5}; do
  if [ $i -eq 3 ]; then
    continue              # jumps over i=3
  fi
  echo "Number $i"
  if [ $i -eq 4 ]; then
    break                 # ends the loop when i=4
  fi
done
\end{lstlisting}

\subsection{if}
\begin{lstlisting}[language=bash]
#!/bin/bash
num=10
if [ $num -gt 10 ]; then
  echo "Number is greater than 10"
elif [ $num -eq 10 ]; then
  echo "Number is exactly 10"
else
  echo "Number is less than 10"
fi
\end{lstlisting}

\subsection{case}
\begin{lstlisting}[language=bash]
#!/bin/bash
case $variable in
  pattern1) commands ;; 
  pattern2) commands ;; 
  *) default_commands ;;
esac
\end{lstlisting}

\section{Logging}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|/var/log/| \> Common path for Linux logs (requires root) \\
	\> \verb|logger "message"| \> Writes message to system log \\
\end{tabbing}

\subsection{Custom Logging Example}
\begin{lstlisting}[language=bash]
echo "$(date '+%Y-%m-%d %H:%M:%S') - message" >> ~/logs/logfile.log
\end{lstlisting}

\subsection{Timestamp}
\begin{lstlisting}[language=bash]
#!/bin/bash 

today=$(date +"%Y-%m-%d_%H-%M-%S")
echo "$today"
\end{lstlisting}

\section{Error Handling}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|set -e| \> Ends script on any error \\
	\> \verb|set +e| \> Deactivates ending on errors \\
	\> \verb|set -u| \> Treats undefined variables as an error \\
	\> \verb|set -o pipefail| \> Makes \$? reflect the last failed pipe command \\
	\> \verb|set +o pipefail| \> Deactivates pipefail \\
	\> \verb|2> error.log| \> Writes errors to \verb|error.log| \\
	\> \verb|set -x| \> Activates debugging \\
	\> \verb|set +x| \> Deactivates debugging \\
	\> \verb|command 2> /dev/null| \> Suppresses error messages \\
\end{tabbing}

\subsection{Exit Codes}
\begin{lstlisting}[language=bash]
#!/bin/bash
if [ "$1" == "test" ]; then  % Fixed: Added missing [
  exit 0 
else 
  exit 1  # 1 to 255
fi
echo $?  # Shows the last exit code
\end{lstlisting}

\subsection{Error Variables}
{\small
	\begin{tabular}{l|ll|l}
		1   & Operation not permitted                           & 2   & No such file or directory                   \\
		3   & No such process                                   & 4   & Interrupted system call                     \\
		5   & Input/output error                                & 6   & No such device or address                   \\
		7   & Argument list too long                            & 8   & Exec format error                           \\
		9   & Bad file descriptor                               & 10  & No child processes                          \\
		11  & Resource temporarily unavailable                  & 12  & Cannot allocate memory                      \\
		14  & Bad address                                       & 15  & Block device required                       \\
		16  & Device or resource busy                           & 17  & File exists                                 \\
		18  & Invalid cross-device link                         & 19  & No such device                              \\
		20  & Not a directory                                   & 21  & Is a directory                              \\
		22  & Invalid argument                                  & 23  & Too many open files in system               \\
		24  & Too many open files                               & 25  & Inappropriate ioctl for device              \\
		26  & Text file busy                                    & 27  & File too large                              \\
		28  & No space left on device                           & 29  & Illegal seek                                \\
		30  & Read-only file system                             & 31  & Too many links                              \\
		32  & Broken pipe                                       & 33  & Numerical argument out of domain            \\
		34  & Numerical result out of range                     & 35  & Resource deadlock avoided                   \\
		36  & File name too long                                & 37  & No locks available                          \\
		40  & Too many levels of symbolic links                 & 42  & No message of desired type                  \\
		43  & Identifier removed                                & 44  & Channel number out of range                 \\
		45  & Level 2 not synchronized                          & 46  & Level 3 halted                              \\
		47  & Level 3 reset                                     & 48  & Link number out of range                    \\
		49  & Protocol driver not attached                      & 50  & No CSI structure available                  \\
		51  & Level 2 halted                                    & 52  & Invalid exchange                            \\
		53  & Invalid request descriptor                        & 54  & Exchange full                               \\
		55  & No anode                                          & 56  & Invalid request code                        \\
		57  & Invalid slot                                      & 59  & Bad font file format                        \\
		60  & Device not a stream                               & 61  & No data available                           \\
		62  & Timer expired                                     & 63  & Out of streams resources                    \\
		64  & Machine is not on the network                     & 65  & Package not installed                       \\
		66  & Object is remote                                  & 67  & Link has been severed                       \\
		68  & Advertise error                                   & 69  & Srmount error                               \\
		70  & Communication error on send                       & 71  & Protocol error                              \\
		72  & Multihop attempted                                & 73  & RFS specific error                          \\
		74  & Bad message                                       & 75  & Value too large for defined data type       \\
		76  & Name not unique on network                        & 77  & File descriptor in bad state                \\
		78  & Remote address changed                            & 79  & Can not access a needed shared library      \\
		80  & Accessing a corrupted shared library              & 81  & lib section in out corrupted                \\
		82  & Attempting to link in too many shared libraries   & 83  & Cannot exec a shared library directly       \\
		84  & Invalid or incomplete multibyte or wide character & 85  & Interrupted system call should be restarted \\
		86  & Streams pipe error                                & 87  & Too many users                              \\
		88  & Socket operation on non-socket                    & 89  & Destination address required                \\
		90  & Message too long                                  & 91  & Protocol wrong type for socket              \\
		92  & Protocol not available                            & 93  & Protocol not supported                      \\
		94  & Socket type not supported                         & 95  & Operation not supported                     \\
		96  & Protocol family not supported                     & 97  & Address family not supported by protocol    \\
		98  & Address already in use                            & 99  & Cannot assign requested address             \\
		100 & Network is down                                   & 101 & Network is unreachable                      \\
		102 & Network dropped connection on reset               & 103 & Software caused connection abort            \\
		104 & Connection reset by peer                          & 105 & No buffer space available                   \\
		108 & Cannot send after transport endpoint shutdown     & 109 & Too many references                         \\
		110 & Connection timed out                              & 111 & Connection refused                          \\
		112 & Host is down                                      & 113 & No route to host                            \\
		116 & Stale file handle                                 & 117 & Structure needs cleaning                    \\
		118 & Not a XENIX named type file                       & 119 & No XENIX semaphores available               \\
		122 & Disk quota exceeded                               & 123 & No medium found                             \\
		125 & Operation canceled                                & 126 & Required key not available                  \\
		127 & Key has expired                                   & 128 & Key has been revoked                        \\
		129 & Key was rejected by service                       & 130 & Owner died                                  \\
		131 & State not recoverable                             & 132 & Operation not possible due to RF-kill       \\
		133 & Memory page has hardware error                    &                                                   \\
	\end{tabular}
}

\section{Functions}
\begin{lstlisting}[language=bash]
#!/bin/bash
my_function() {
  echo "Hello World!"
}
my_function

# function with parameters 
ym_function() {
  local num=$1 
  local max=$2 
  echo "num: $num max: $max"
}

ym_function 3 45
\end{lstlisting}

\section{GUI}
\subsection{Zenity}
Zenity ist ein Tool für GUI-Dialoge in Bash-Skripten.

\subsubsection*{Haupt-Dialog-Typen}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|--calendar| \> Kalender-Dialog \\
	\> \verb|--entry| \> Text-Eingabe-Dialog \\
	\> \verb|--error| \> Fehler-Dialog \\
	\> \verb|--file-selection| \> Datei-Auswahl-Dialog \\
	\> \verb|--info| \> Info-Dialog \\
	\> \verb|--list| \> Listen-Dialog \\
	\> \verb|--notification| \> Benachrichtigung \\
	\> \verb|--progress| \> Fortschritts-Dialog \\
	\> \verb|--question| \> Frage-Dialog \\
	\> \verb|--text-info| \> Text-Info-Dialog \\
	\> \verb|--warning| \> Warnungs-Dialog \\
	\> \verb|--scale| \> Skalen-Dialog \\
	\> \verb|--color-selection| \> Farb-Auswahl-Dialog \\
	\> \verb|--password| \> Passwort-Dialog \\
	\> \verb|--forms| \> Formular-Dialog \\
\end{tabbing}

\subsubsection*{Gängige Optionen}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|--title=TITLE| \> Setzt Dialog-Titel \\
	\> \verb|--text=STRING| \> Setzt Dialog-Text \\
	\> \verb|--width=WIDTH| \> Setzt Breite \\
	\> \verb|--height=HEIGHT| \> Setzt Höhe \\
	\> \verb|--timeout=TIMEOUT| \> Setzt Timeout in Sekunden \\
	\> \verb|--no-wrap| \> Kein Text-Umbruch \\
	\> \verb|--no-markup| \> Kein Pango-Markup \\
\end{tabbing}

\subsubsection*{Beispiele}
\begin{lstlisting}[language=bash]
zenity --info --text "Hallo Welt!"  # Info-Dialog
zenity --entry --text "Name eingeben"  # Eingabe-Dialog
zenity --question --text "Fortfahren?"  # Frage-Dialog
zenity --file-selection  # Datei-Auswahl
zenity --progress --pulsate  # Fortschrittsbalken
\end{lstlisting}

\subsection{YAD}
YAD (Yet Another Dialog) ist eine Erweiterung von Zenity mit mehr Features.

\subsubsection*{Haupt-Dialog-Typen}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|--calendar| \> Kalender-Dialog \\
	\> \verb|--color| \> Farb-Auswahl-Dialog \\
	\> \verb|--dnd| \> Drag-and-Drop-Box \\
	\> \verb|--entry| \> Text-Eingabe-Dialog \\
	\> \verb|--icons| \> Icons-Box \\
	\> \verb|--file| \> Datei-Auswahl-Dialog \\
	\> \verb|--font| \> Schrift-Auswahl-Dialog \\
	\> \verb|--form| \> Formular-Dialog \\
	\> \verb|--html| \> HTML-Dialog \\
	\> \verb|--list| \> Listen-Dialog \\
	\> \verb|--multi-progress| \> Multi-Fortschritts-Dialog \\
	\> \verb|--notebook| \> Notebook-Dialog \\
	\> \verb|--notification| \> Benachrichtigung \\
	\> \verb|--print| \> Druck-Dialog \\
	\> \verb|--progress| \> Fortschritts-Dialog \\
	\> \verb|--text-info| \> Text-Info-Dialog \\
	\> \verb|--scale| \> Skalen-Dialog \\
\end{tabbing}

\subsubsection*{Gängige Optionen}
\begin{tabbing}
	\= \hspace{60mm} \= \hspace{80mm} \kill
	\> \verb|--title=TITLE| \> Setzt Dialog-Titel \\
	\> \verb|--text=STRING| \> Setzt Dialog-Text \\
	\> \verb|--button=BUTTON:ID| \> Fügt Button hinzu \\
	\> \verb|--entry-text=STRING| \> Initialer Text in Eingabe \\
	\> \verb|--filename=FILENAME| \> Initiale Datei \\
	\> \verb|--column=STRING[:TYPE]| \> Definiert Spalte in Liste \\
	\> \verb|--bar=LABEL[:TYPE]| \> Fügt Fortschrittsbalken hinzu \\
\end{tabbing}

\subsubsection*{Beispiele}
\begin{lstlisting}[language=bash]
yad --info --text "Hallo Welt!"  # Info-Dialog
yad --entry --text "Name eingeben"  # Eingabe-Dialog
yad --form --field="Name" --field="Alter:NUM"  # Formular
yad --file  # Datei-Auswahl
yad --progress --pulsate  # Fortschrittsbalken
\end{lstlisting}

\section{Example}
\begin{lstlisting}[language=bash] 
#!/bin/bash
# Bash Cheat Sheet: Fortschrittsbalken, Dateisuche und Logging

# Logfile- und Suchpfade
logfile="$HOME/prog/bash/testing/log/logfile.log"
logpath=$(dirname "$logfile")
searchpath="$HOME/prog/bash/testing"
searchword="test"  # Standard-Suchwort
batchsize=5        # Standard-Batch-Groesse
files=()

# Zeitstempel holen
get_timestamp() {
  timestamp=$(date +"%Y-%m-%d_%H:%M:%S")
}

# Logging initialisieren
logging() {
  get_timestamp
  echo "$timestamp Log path: $logpath" | tee -a "$logfile"
  echo "$timestamp Log file: $logfile" | tee -a "$logfile"

  # Logfile pruefen/erstellen
  if [[ -f "$logfile" ]]; then
    get_timestamp
    echo "$timestamp Logfile exists" | tee -a "$logfile"
  else
    get_timestamp
    echo "$timestamp Creating logfile" | tee -a "$logfile"
    mkdir -p "$logpath" || { echo "$timestamp Failed to create logpath" | tee -a "$logfile"; exit 1; }
    touch "$logfile" || { echo "$timestamp Failed to create logfile" | tee -a "$logfile"; exit 2; }
    echo "$timestamp Logfile created" | tee -a "$logfile"
  fi
}

# Fehlerbehandlung
handling() {
  local error="$1"
  get_timestamp
  case $error in
    0) echo "$timestamp Script completed successfully" | tee -a "$logfile";;
    1) echo "$timestamp Directory error" | tee -a "$logfile"; exit 1;;
    2) echo "$timestamp Logfile error" | tee -a "$logfile"; exit 2;;
    4) echo "$timestamp nvim not installed" | tee -a "$logfile"; exit 4;;
    *) echo "$timestamp Unknown error: $error" | tee -a "$logfile"; exit $error;;
  esac
}

# Argumente pruefen
argcheck() {
  while getopts "k:b:" opt; do
    get_timestamp
    case $opt in
      k) searchword="$OPTARG"
         echo "$timestamp Search word set to $searchword" | tee -a "$logfile";;
      b) batchsize="$OPTARG"
         echo "$timestamp Batch size set to $batchsize" | tee -a "$logfile";;
      \?) echo "$timestamp Invalid option" | tee -a "$logfile"; exit 1;;
      :) echo "$timestamp Option -$opt requires an argument" | tee -a "$logfile"; exit 1;;
    esac
  done
}

# Fortschrittsbalken erstellen
progress_bar() {
  local i=$1         # Current number of processed files
  local len=$2       # Total number of files
  local perc=$((i * 100 / len))  # Percentage of progress
  local filled=$((perc / 4))     # 25-character progress bar
  local empty=$((25 - filled))   # Remaining empty spaces
  local bar="["      # Start of bar
  for ((j=0; j<filled; j++)); do
    bar+="|"         # Filled part
  done
  for ((j=0; j<empty; j++)); do
    bar+=" "         # Empty part
  done
  bar+="] $perc%"    # End of bar with percentage
  echo -ne "\rProgress $i/$len $bar"
}

# Dateien finden (mit mapfile)
finding() {
  get_timestamp
  echo "$timestamp Searching for *$searchword*.log files..." | tee -a "$logfile"
  mapfile -t -d '' files < <(find "$searchpath" -type f -iname "*$searchword*.log" -print0 | sort -z)
  len=${#files[@]}
  if [[ $len -eq 0 ]]; then
    echo "$timestamp No files found" | tee -a "$logfile"
    exit 1
  fi
  echo "$timestamp Found $len files: ${files[*]}" | tee -a "$logfile"
}

# Dateien finden (ohne mapfile)
findingNoMapfile() {
  get_timestamp
  local files_no_map=()
  echo "$timestamp Searching without mapfile..." | tee -a "$logfile"
  while IFS= read -r -d '' file; do
    files_no_map+=("$file")
  done < <(find "$searchpath" -type f -iname "*$searchword*.log" -print0 | sort -z)
  len=${#files_no_map[@]}
  if [[ $len -eq 0 ]]; then
    echo "$timestamp No files found (no mapfile)" | tee -a "$logfile"
    exit 1
  fi
  echo "$timestamp Found $len files (no mapfile): ${files_no_map[*]}" | tee -a "$logfile"
}

# Dateien in Batches verarbeiten
process_files() {
  local files=("$@")
  get_timestamp
  echo "$timestamp Processing batch: ${ telle -a "$logfile"
  if command -v nvim >/dev/null 2>&1; then
    nvim -O "${files[@]}" -c "/$searchword"  # Suche nach searchword in Neovim
  else
    echo "$timestamp nvim not installed, skipping" | tee -a "$logfile"
  fi
}

# Hauptprogramm
trap 'handling $?' EXIT
logging
argcheck "$@"
finding
findingNoMapfile
for ((i=0; i<${#files[@]}; i+=batchsize)); do
  local current=$((i + batchsize < ${#files[@]} ? i + batchsize : ${#files[@]}))
  progress_bar "$current" "${#files[@]}"
  process_files "${files[@]:i:batchsize}"
  get_timestamp
  echo "$timestamp Processed batch $((i/batchsize + 1))" | tee -a "$logfile"
  sleep 0.5
done
progress_bar "${#files[@]}" "${#files[@]}"
echo ""

# Beispiel Here-Document
tee -a "$logfile" <<EOF
$timestamp Here-Document example
Text written to $logfile and CLI
EOF
\end{lstlisting}

\end{document}

